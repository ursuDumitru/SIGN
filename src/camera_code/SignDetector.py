import numpy as np

from keras.models import load_model
from abc import ABC, abstractmethod


class SignDetector(ABC):
    """
    This class is used to initialize the model for sign detection.
    """

    def __init__(self, model_weights_path) -> None:
        """
        Initialize the SignDetector object.
            - model: keras.engine.functional.Functional, the model used for sign detection.
            - INSERT_DELAY: int, the delay between inserting signs in real time detection.
        :param model_weights_path: str, the path to the model weights file.
        """
        self.model = load_model(model_weights_path)

    @abstractmethod
    def make_prediction(self, landmark_list, dm):
        pass

    @abstractmethod
    def get_label_and_prediction(self, landmark_list, dm):
        pass


class SignDetectorStatic(SignDetector):
    """
    This class is an extension of the SignDetector class.
    It is used to predict static signs.
    """

    def __init__(self, model_weights_path) -> None:
        """
        Initialize the SignDetectorStatic object.
        :param model_weights_path: str, path to the static model weights file(.h5).
        """
        super(SignDetectorStatic, self).__init__(model_weights_path)

    def make_prediction(self, landmark_list, dm):
        """
        This method is used to make a prediction based on the landmarks
        generated by the hands detector(MediaPipe).
        :param landmark_list: list, the normalized landmarks of the hands.
        :param dm: DataManipulator, Static or Dynamic.
        :return prediction: np.array, the prediction made by the model.
        """
        dm.get_sign_labels()
        return self.model.predict(np.array([landmark_list]))

    def get_label_and_prediction(self, landmark_list, dm):
        """
        This method is used to get the prediction and the label of the sign.
        :param landmark_list: list, the normalized landmarks of the hands.
        :param dm: DataManipulator, Static.
        :return: label, prediction: detected sign label and the accuracy of the prediction.
        """
        prediction = self.make_prediction(landmark_list, dm)
        label = dm.sign_labels[np.argmax(prediction)]
        confidence = np.max(prediction)

        return label, confidence


class SignDetectorDynamic(SignDetector):
    """
    This class is an extension of the SignDetector class.
    It is used to predict dynamic signs.
    """

    def __init__(self, model_weights_path) -> None:
        """
        Initialize the SignDetectorDynamic object.
        :param model_weights_path: str, path to the dynamic model weights file(.h5).
        """
        self.real_time_sequence = []  # TODO, does this need to be reset ?
        super(SignDetectorDynamic, self).__init__(model_weights_path)

    def make_prediction(self, landmark_list, dm):
        """
        This method is used to make a prediction based on the landmarks
        generated by the hands detector(MediaPipe).
        :param landmark_list: list, the normalized landmarks of the hands.
        :param dm: DataManipulator, Static or Dynamic.
        :return prediction: np.array, the prediction made by the model.
        """
        dm.get_sign_labels()
        return self.model.predict(np.array([landmark_list]))

    def get_label_and_prediction(self, landmark_list, dm):
        """
        This method is used to get the prediction and the label of the sign.
        :param landmark_list: list, the normalized landmarks of the hands.
        :param dm: DataManipulator, Dynamic.
        :return: label, prediction: detected sign label and the accuracy of the prediction.
        """
        self.real_time_sequence.append(landmark_list)
        self.real_time_sequence = self.real_time_sequence[-30:]
        label = confidence = None

        if len(self.real_time_sequence) == 30:
            prediction = self.make_prediction(self.real_time_sequence, dm)
            label = dm.sign_labels[np.argmax(prediction)]
            confidence = np.max(prediction)

        return label, confidence
